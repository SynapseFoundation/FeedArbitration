const crypto = require('crypto');
const fs = require('fs');
const IPFS = require('ipfs');
const Web3 = require('web3');

const SynapseMarket = web3.eth.contract("../../build/src_market_contracts_Market_sol_SynapseMarket.abi");

// Establish an IPFS connection with pubsub enabled
const ipfs = new IPFS({
    repo: 'ipfs/synapse-subscriber-test/1',
    EXPERIMENTAL: {
        pubsub: true
    }
});

const web3 = new Web3();

class SynapseInternalSubscription {
    constructor(provider, secret, nonce, endblock, uuid) {
        this.provider = provider;
        this.secret = secret;
        this.nonce = nonce;

        // Create a cipher with the secret and nonce as buffers, not hex strings.
        this.cipher = crypto.createCipheriv('aes-256-ctr', new Buffer(secret, 16),
                                                           new Buffer(nonce, 16));

        this.endblock = endblock;
        this.uuid = uuid;
    }

    // Subscribe to the data from this feed
    data(callback) {
        // Subscribe to the data
        ipfs.pubsub.subscribe(this.uuid, (err, data) => {
            // Decrypt the data
            const decrypted = this.cipher.update(data['data'])
                                         .final();

            callback(decrypted);
        });
    }

    // Serialize object for saving
    toObject() {
        return {
            provider: this.provider,
            secret: this.secret,
            nonce: this.nonce,
            endblock: this.endblock,
            uuid: this.uuid
        };
    }

    // Establish from serialized object for loading
    static fromObject(data) {
        return new SynapseInternalSubscription(
            data.provider,
            data.secret,
            data.nonce,
            data.endblock,
            data.uuid
        );
    }
}

class SynapseSubscriber {
    constructor(marketAddress, configFile="~/.synapsesubscriber") {
        this.marketInstance = SynapseMarket.at(marketAddress);

        this.checkForRegister(configFile, () => {
            // TODO
        });
    }

    // Check whether or not we need to register, if so register
    checkForRegister(configFile, callback) {
        // Already regsitered
        if ( fs.existsSync(configFile) ) {
            const data = JSON.parse(fs.readFileSync(configFile));

            this.private_key = data.private_key;

            // Generate a secp256k1 keypair
            this.keypair = crypto.createECDH('secp224k1');
            this.keypair.setPrivateKey(data.private_key, 'hex');

            // Load the subscriptions into internal objects
            this.subscriptions = data.subscriptions.map(data => SynapseInternalSubscription.fromObject(data));

            callback();
            return;
        }

        this.keypair = crypto.createECDH('secp224k1');
        this.keypair.generateKeys('hex', 'compressed');

        console.log("Successfully registered");

        fs.writeFileSync("~/.synapsesubscriber", JSON.stringify({
            private_key: this.keypair.getPrivateKey('hex'),
            subscriptions: []
        }));

        this.subscriptions = [];

        callback();
    }

    // Create a new subscription
    newSubsription(group, callback) {
        // Conver group to bytes32 string
        group = '0x' + (new Buffer(group)).toString('hex');

        // Send the request
        this.marketInstance.requestSynapseProvider(group, {
            gas: 300000 // TODO - not this
        }, (err, result) => {
            if ( err ) {
                throw err;
            }

            // Watch for SynapseProviderFound events
            const event = this.marketInstance.SynapseProviderFound();

            event.watch((err, result2) => {
                if ( err ) {
                    throw err;
                }

                // Make sure it was generated by the above request
                if ( result2.transactionHash != result.transactionHash ) {
                    return;
                }

                // Get the index of the provider
                const provider_index = result2.index;

                this.newSubscriptionWithIndex(provider_index, group, callback);
            });
        });
    }

    // Start a subscription with a provider index
    newSubscriptionWithIndex(provider_index, group, callback) {
        // Get the information of the provider
        const providers_address = this.marketInstance.getProviderAddress(group, provider_index);
        const providers_public = this.marketInstance.getProviderPublic(group, provider_index);

        // Do the key exchange
        const secrethex = this.keypair.computeSecret(providers_public, 'hex');

        // Generate a nonce
        const nonce = crypto.randomBytes(32);
        const noncehex = "0x" + nonce.toString('hex');

        // Generate a UUID
        const uuid = crypto.randomBytes(32);

        // Encrypt it with the secret key
        const cipher = crypto.createCipheriv('aes-256-ctr', new Buffer(secrethex, 16), nonce);
        const euuid = "0x" + cipher.update(uuid)
                                   .final('hex');

        // Get my public key
        const public_key = "0x" + this.keypair.getPublicKey('hex');

        // Initiate the data feed
        this.marketInstance.initSynapseDataFeed(group, providers_address, public_key, euuid, noncehex, (err, result) => {
            if ( err ) {
                throw err;
            }

            // Create the subscription object
            const subscription = new SynapseInternalSubscription(public_key, secrethex, noncehex, uuid.toString('base64'));
            subscription.data(callback);
        });
    }
}

module.exports = SynapseSubscriber;
