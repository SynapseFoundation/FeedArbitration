const crypto = require('crypto');
const fs = require('fs');
const Web3 = require('web3');

const SynapseMarket = web3.eth.contract("../../build/src_market_contracts_Market_sol_SynapseMarket.abi");
const SynapseSubscription = require('./subscription.js');

const web3 = new Web3();

class SynapseSubscriber {
    constructor(marketAddress, configFile="~/.synapsesubscriber", callback = undefined) {
        this.marketInstance = SynapseMarket.at(marketAddress);

        this.checkForRegister(configFile, callback);
    }

    // Check whether or not we need to register, if so register
    checkForRegister(configFile, callback) {
        // Already regsitered
        if ( fs.existsSync(configFile) ) {
            const data = JSON.parse(fs.readFileSync(configFile));

            this.private_key = data.private_key;

            // Generate a secp224k1 keypair
            this.keypair = crypto.createECDH('secp224k1');
            this.keypair.setPrivateKey(data.private_key, 'hex');

            // Load the subscriptions into internal objects
            this.subscriptions = data.subscriptions.map(data => {
                const obj = SynapseSubscription.fromObject(data);

                // If a callback was passed, initiate the stream with that
                if ( callback ) {
                    obj.data(callback);
                }

                return obj;
            });

            return;
        }

        this.keypair = crypto.createECDH('secp224k1');
        this.keypair.generateKeys('hex', 'compressed');

        console.log("Successfully registered");

        fs.writeFileSync("~/.synapsesubscriber", JSON.stringify({
            private_key: this.keypair.getPrivateKey('hex'),
            subscriptions: []
        }));

        this.subscriptions = [];
    }

    // Create a new subscription
    newSubsription(group, callback) {
        // Conver group to bytes32 string
        group = '0x' + (new Buffer(group)).toString('hex');

        console.log("Looking for a provider of data");

        // Send the request
        this.marketInstance.requestSynapseProvider(group, {
            gas: 300000 // TODO - not this
        }, (err, result) => {
            if ( err ) {
                throw err;
            }

            console.log("Sent the request");

            // Watch for SynapseProviderFound events
            const event = this.marketInstance.SynapseProviderFound();

            event.watch((err, found_res) => {
                if ( err ) {
                    throw err;
                }

                // Make sure it was generated by the above request
                if ( found_res.transactionHash != result.transactionHash ) {
                    return;
                }

                console.log("Found a provider of data");

                // Get the index of the provider
                const provider_index = found_res.args.index;

                this.newSubscriptionWithIndex(provider_index, group, callback);
            });
        });
    }

    // Start a subscription with a provider index
    newSubscriptionWithIndex(provider_index, group, callback) {
        console.log("Starting subscription with index", provider_index);
        // Get the information of the provider
        const providers_address = this.marketInstance.getProviderAddress(group, provider_index);
        const providers_public = this.marketInstance.getProviderPublic(group, provider_index);

        // Do the key exchange
        const secrethex = this.keypair.computeSecret(providers_public, 'hex');

        // Generate a nonce
        const nonce = crypto.randomBytes(32);
        const noncehex = "0x" + nonce.toString('hex');

        // Generate a UUID
        const uuid = crypto.randomBytes(32);

        // Encrypt it with the secret key
        const cipher = crypto.createCipheriv('aes-256-ctr', new Buffer(secrethex, 16), nonce);
        const euuid = "0x" + cipher.update(uuid)
                                   .final('hex');

        // Get my public key
        const public_key = "0x" + this.keypair.getPublicKey('hex');

        // Initiate the data feed
        this.marketInstance.initSynapseDataFeed(group, providers_address, public_key, euuid, noncehex, (err, result) => {
            if ( err ) {
                throw err;
            }

            console.log("Data feed initiated");

            // Create the subscription object
            const subscription = new SynapseSubscription(public_key, secrethex, noncehex, uuid.toString('base64'));
            subscription.data(callback);
        });
    }
}

module.exports = SynapseSubscriber;
