const crypto = require('crypto');
const fs = require('fs');
const Web3 = require('web3');

const SynapseSubscription = require('./subscription.js');

//market contract
const file = "./market/contracts/abi.json";
const abi = JSON.parse(fs.readFileSync(file));
const marketAddress = "0x98f6d007a840782eea0fbc6584ab95e8c86d677e";
const SynapseMarket = new web3.eth.Contract(abi, marketAddress);

// Create a sending RPC
const rpcHost = "http://localhost:8545";
const web3 = new Web3(Web3.givenProvider || rpcHost);
const SynapseMarket = new web3.eth.Contract(abi, marketAddress);

// Create a listening RPC
const rpcHost_listen = "ws://localhost:8546";
const web3_listen = new Web3(Web3.givenProvider || rpcHost_listen);
const SynapseMarket_listen = new web3_listen.eth.Contract(abi, marketAddress);

//accounts
const accounts = require('./account.js');
const privateKeyHex = "0x8d2246c6f1238a97e84f39e18f84593a44e6622b67b8cebb7788320486141f95";
const account = new accounts(privateKeyHex);

account.setWeb3(web3);

class SynapseSubscriber {
    constructor(marketAddress, configFile="~/.synapsesubscriber", callback = undefined) {
        this.marketInstance = SynapseMarket;

        this.checkForRegister(configFile, callback);
    }

    // Check whether or not we need to register, if so register
    checkForRegister(configFile, callback) {
        // Already regsitered
        if ( fs.existsSync(configFile) ) {
            const data = JSON.parse(fs.readFileSync(configFile));

            this.private_key = data.private_key;

            // Generate a secp224k1 keypair
            this.keypair = crypto.createECDH('secp224k1');
            this.keypair.setPrivateKey(data.private_key, 'hex');

            // Load the subscriptions into internal objects
            this.subscriptions = data.subscriptions.map(data => {
                const obj = SynapseSubscription.fromObject(data);

                // If a callback was passed, initiate the stream with that
                if ( callback ) {
                    obj.data(callback);
                }

                return obj;
            });

            return;
        }

        this.keypair = crypto.createECDH('secp224k1');
        this.keypair.generateKeys('hex', 'compressed');

        console.log("Successfully registered");

        fs.writeFileSync("~/.synapsesubscriber", JSON.stringify({
            private_key: this.keypair.getPrivateKey('hex'),
            subscriptions: []
        }));

        this.subscriptions = [];
    }

    // Create a new subscription
    newSubsription(group, callback) {
        // Conver group to bytes32 string
        group = '0x' + (new Buffer(group)).toString('hex');

        console.log("Looking for a provider of data");

        // Send the request
        this.marketInstance.methods.requestSynapseProvider(group).send({
            from: web3.eth.accounts.wallet[0].address,
            gas: 300000 // TODO - not this
        }, (err, result) => {
            if ( err ) {
                throw err;
            };

            console.log("Sent the request");

            // Watch for SynapseProviderFound events
            const event = this.marketInstance.SynapseProviderFound();

            event.watch((err, found_res) => {
                if ( err ) {
                    throw err;
                }

                // Make sure it was generated by the above request
                if ( found_res.transactionHash != result.transactionHash ) {
                    return;
                }

                console.log("Found a provider of data");

                // Get the index of the provider
                const provider_index = found_res.args.index;

                this.newSubscriptionWithIndex(provider_index, group, callback);
            });
        });
    }

    // Start a subscription with a provider index
    newSubscriptionWithIndex(provider_index, group, callback) {
        console.log("Starting subscription with index", provider_index);
        // Get the information of the provider
        const providers_address = this.marketInstance.getProviderAddress(group, provider_index);
        const providers_public = this.marketInstance.getProviderPublic(group, provider_index);

        // Do the key exchange
        const secrethex = this.keypair.computeSecret(providers_public, 'hex');

        // Generate a nonce
        const nonce = crypto.randomBytes(32);
        const noncehex = "0x" + nonce.toString('hex');

        // Generate a UUID
        const uuid = crypto.randomBytes(32);

        // Encrypt it with the secret key
        const cipher = crypto.createCipheriv('aes-256-ctr', new Buffer(secrethex, 16), nonce);
        const euuid = "0x" + cipher.update(uuid)
                                   .final('hex');

        // Get my public key
        const public_key = "0x" + this.keypair.getPublicKey('hex');

        // Initiate the data feed
        this.marketInstance.initSynapseDataFeed(group, providers_address, public_key, euuid, noncehex).send({
            from: web3.eth.accounts.wallet[0].address,
            gas: 300000 // TODO - not this
       } , (err, result) => {
            if ( err ) {
                throw err;
            }

            console.log("Data feed initiated");

            // Create the subscription object
            const subscription = new SynapseSubscription(public_key, secrethex, noncehex, uuid.toString('base64'));
            subscription.data(callback);
        });
    }
}

module.exports = SynapseSubscriber;
